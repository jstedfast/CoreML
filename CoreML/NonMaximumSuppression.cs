// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: NonMaximumSuppression.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace CoreML.Specification {

  /// <summary>Holder for reflection information generated from NonMaximumSuppression.proto</summary>
  public static partial class NonMaximumSuppressionReflection {

    #region Descriptor
    /// <summary>File descriptor for NonMaximumSuppression.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static NonMaximumSuppressionReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChtOb25NYXhpbXVtU3VwcHJlc3Npb24ucHJvdG8SFENvcmVNTC5TcGVjaWZp",
            "Y2F0aW9uGhREYXRhU3RydWN0dXJlcy5wcm90byLABAoVTm9uTWF4aW11bVN1",
            "cHByZXNzaW9uEkYKB3BpY2tUb3AYASABKAsyMy5Db3JlTUwuU3BlY2lmaWNh",
            "dGlvbi5Ob25NYXhpbXVtU3VwcHJlc3Npb24uUGlja1RvcEgAEj8KEXN0cmlu",
            "Z0NsYXNzTGFiZWxzGGQgASgLMiIuQ29yZU1MLlNwZWNpZmljYXRpb24uU3Ry",
            "aW5nVmVjdG9ySAESPQoQaW50NjRDbGFzc0xhYmVscxhlIAEoCzIhLkNvcmVN",
            "TC5TcGVjaWZpY2F0aW9uLkludDY0VmVjdG9ySAESFAoMaW91VGhyZXNob2xk",
            "GG4gASgBEhsKE2NvbmZpZGVuY2VUaHJlc2hvbGQYbyABKAESIwoaY29uZmlk",
            "ZW5jZUlucHV0RmVhdHVyZU5hbWUYyAEgASgJEiQKG2Nvb3JkaW5hdGVzSW5w",
            "dXRGZWF0dXJlTmFtZRjJASABKAkSJQocaW91VGhyZXNob2xkSW5wdXRGZWF0",
            "dXJlTmFtZRjKASABKAkSLAojY29uZmlkZW5jZVRocmVzaG9sZElucHV0RmVh",
            "dHVyZU5hbWUYywEgASgJEiQKG2NvbmZpZGVuY2VPdXRwdXRGZWF0dXJlTmFt",
            "ZRjSASABKAkSJQocY29vcmRpbmF0ZXNPdXRwdXRGZWF0dXJlTmFtZRjTASAB",
            "KAkaGwoHUGlja1RvcBIQCghwZXJDbGFzcxgBIAEoCEITChFTdXBwcmVzc2lv",
            "bk1ldGhvZEINCgtDbGFzc0xhYmVsc0ICSANQAGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::CoreML.Specification.DataStructuresReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::CoreML.Specification.NonMaximumSuppression), global::CoreML.Specification.NonMaximumSuppression.Parser, new[]{ "PickTop", "StringClassLabels", "Int64ClassLabels", "IouThreshold", "ConfidenceThreshold", "ConfidenceInputFeatureName", "CoordinatesInputFeatureName", "IouThresholdInputFeatureName", "ConfidenceThresholdInputFeatureName", "ConfidenceOutputFeatureName", "CoordinatesOutputFeatureName" }, new[]{ "SuppressionMethod", "ClassLabels" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::CoreML.Specification.NonMaximumSuppression.Types.PickTop), global::CoreML.Specification.NonMaximumSuppression.Types.PickTop.Parser, new[]{ "PerClass" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///
  /// Non-maximum suppression of axis-aligned bounding boxes.
  ///
  /// This is used primarily for object detectors that tend to produce multiple
  /// boxes around a single object.  This is a byproduct of the detector's
  /// robustness to spatial translation. If there are two or more bounding boxes
  /// that are very similar to one another, the algorithm should return only a
  /// single representative.
  ///
  /// Similarity between two bounding boxes is measured by intersection-over-union
  /// (IOU), the fraction between the area of intersection and area of the union.
  /// Here is an example where the areas can be calculated by hand by counting glyphs::
  ///
  ///     +-------+                            +-------+
  ///     |       |                            |       |
  ///     |    +------+          +--+          |       +---+
  ///     |    |  |   |          |  |          |           |
  ///     +-------+   |          +--+          +----+      |
  ///          |      |                             |      |
  ///          +------+                             +------+
  ///                        Intersection         Union
  ///      IOU: 0.16      =       12       /       73
  ///
  /// All IOU scores are fractions betwen 0.0 (fully disjoint) and 1.0 (perfect
  /// overlap). The standard algorithm (PickTop) is defined as follows:
  ///
  ///  1. Sort boxes by descending order of confidence
  ///  2. Take the top one and mark it as keep
  ///  3. Suppress (mark it as discard) all boxes within a fixed IOU radius of the
  ///     keep box
  ///  4. Go to 2 and repeat on the subset of boxes not already kept or discarded
  ///  5. When all boxes are processed, output only the ones marked as keep
  ///
  /// Before the algorithm, boxes that fall below the confidence threshold are
  /// discarded.
  /// </summary>
  public sealed partial class NonMaximumSuppression : pb::IMessage<NonMaximumSuppression> {
    private static readonly pb::MessageParser<NonMaximumSuppression> _parser = new pb::MessageParser<NonMaximumSuppression>(() => new NonMaximumSuppression());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NonMaximumSuppression> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::CoreML.Specification.NonMaximumSuppressionReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NonMaximumSuppression() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NonMaximumSuppression(NonMaximumSuppression other) : this() {
      iouThreshold_ = other.iouThreshold_;
      confidenceThreshold_ = other.confidenceThreshold_;
      confidenceInputFeatureName_ = other.confidenceInputFeatureName_;
      coordinatesInputFeatureName_ = other.coordinatesInputFeatureName_;
      iouThresholdInputFeatureName_ = other.iouThresholdInputFeatureName_;
      confidenceThresholdInputFeatureName_ = other.confidenceThresholdInputFeatureName_;
      confidenceOutputFeatureName_ = other.confidenceOutputFeatureName_;
      coordinatesOutputFeatureName_ = other.coordinatesOutputFeatureName_;
      switch (other.SuppressionMethodCase) {
        case SuppressionMethodOneofCase.PickTop:
          PickTop = other.PickTop.Clone();
          break;
      }

      switch (other.ClassLabelsCase) {
        case ClassLabelsOneofCase.StringClassLabels:
          StringClassLabels = other.StringClassLabels.Clone();
          break;
        case ClassLabelsOneofCase.Int64ClassLabels:
          Int64ClassLabels = other.Int64ClassLabels.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NonMaximumSuppression Clone() {
      return new NonMaximumSuppression(this);
    }

    /// <summary>Field number for the "pickTop" field.</summary>
    public const int PickTopFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::CoreML.Specification.NonMaximumSuppression.Types.PickTop PickTop {
      get { return suppressionMethodCase_ == SuppressionMethodOneofCase.PickTop ? (global::CoreML.Specification.NonMaximumSuppression.Types.PickTop) suppressionMethod_ : null; }
      set {
        suppressionMethod_ = value;
        suppressionMethodCase_ = value == null ? SuppressionMethodOneofCase.None : SuppressionMethodOneofCase.PickTop;
      }
    }

    /// <summary>Field number for the "stringClassLabels" field.</summary>
    public const int StringClassLabelsFieldNumber = 100;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::CoreML.Specification.StringVector StringClassLabels {
      get { return classLabelsCase_ == ClassLabelsOneofCase.StringClassLabels ? (global::CoreML.Specification.StringVector) classLabels_ : null; }
      set {
        classLabels_ = value;
        classLabelsCase_ = value == null ? ClassLabelsOneofCase.None : ClassLabelsOneofCase.StringClassLabels;
      }
    }

    /// <summary>Field number for the "int64ClassLabels" field.</summary>
    public const int Int64ClassLabelsFieldNumber = 101;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::CoreML.Specification.Int64Vector Int64ClassLabels {
      get { return classLabelsCase_ == ClassLabelsOneofCase.Int64ClassLabels ? (global::CoreML.Specification.Int64Vector) classLabels_ : null; }
      set {
        classLabels_ = value;
        classLabelsCase_ = value == null ? ClassLabelsOneofCase.None : ClassLabelsOneofCase.Int64ClassLabels;
      }
    }

    /// <summary>Field number for the "iouThreshold" field.</summary>
    public const int IouThresholdFieldNumber = 110;
    private double iouThreshold_;
    /// <summary>
    ///
    /// This defines the radius of suppression. A box is considered to be within
    /// the radius of another box if their IOU score is less than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double IouThreshold {
      get { return iouThreshold_; }
      set {
        iouThreshold_ = value;
      }
    }

    /// <summary>Field number for the "confidenceThreshold" field.</summary>
    public const int ConfidenceThresholdFieldNumber = 111;
    private double confidenceThreshold_;
    /// <summary>
    ///
    /// Remove bounding boxes below this threshold.  The algorithm run-time is
    /// proportional to the square of the number of incoming bounding boxes
    /// (O(N^2)). This threshold is a way to reduce N to make the algorithm
    /// faster. The confidence threshold can be any non-negative value. Negative
    /// confidences are not allowed, since if the output shape is specified to be
    /// larger than boxes after suppression, the unused boxes are filled with
    /// zero confidence. If the prediction is handled by Core Vision, it is also
    /// important that confidences are defined with the following semantics:
    /// 
    ///   1. Confidences should be between 0 and 1
    ///   2. The sum of the confidences for a prediction should not exceed 1, but is
    ///      allowed to be less than 1
    ///   3. The sum of the confidences will be interpreted as the confidence of
    ///      any object (e.g. if the confidences for two classes are 0.2 and 0.4,
    ///it means there is a 60% (0.2 + 0.4) confidence that an object is
    ///present)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double ConfidenceThreshold {
      get { return confidenceThreshold_; }
      set {
        confidenceThreshold_ = value;
      }
    }

    /// <summary>Field number for the "confidenceInputFeatureName" field.</summary>
    public const int ConfidenceInputFeatureNameFieldNumber = 200;
    private string confidenceInputFeatureName_ = "";
    /// <summary>
    ///
    /// Set the name of the confidence input.
    ///
    /// The input should be a multi-array of type double and shape N x C. N is
    /// the number of boxes and C the number of classes. Each row describes the
    /// confidences of each object category being present at that particular
    /// location. Confidences should be nonnegative, where 0.0 means the highest
    /// certainty the object is not present.
    ///
    /// Specifying shape is optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ConfidenceInputFeatureName {
      get { return confidenceInputFeatureName_; }
      set {
        confidenceInputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "coordinatesInputFeatureName" field.</summary>
    public const int CoordinatesInputFeatureNameFieldNumber = 201;
    private string coordinatesInputFeatureName_ = "";
    /// <summary>
    ///
    /// Set the name of the coordinates input.
    ///
    /// The input should be a multi-array of type double and shape N x 4. The
    /// rows correspond to the rows of the confidence matrix. The four values
    /// describe (in order):
    ///
    ///  - x (center location of the box along the horizontal axis)
    ///  - y (center location of the box along the vertical axis)
    ///  - width (size of box along the horizontal axis)
    ///  - height (size of box on along the vertical axis)
    ///
    /// Specifying shape is optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CoordinatesInputFeatureName {
      get { return coordinatesInputFeatureName_; }
      set {
        coordinatesInputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "iouThresholdInputFeatureName" field.</summary>
    public const int IouThresholdInputFeatureNameFieldNumber = 202;
    private string iouThresholdInputFeatureName_ = "";
    /// <summary>
    ///
    /// The iouThreshold can be optionally overridden by specifying this string
    /// and providing a corresponding input of type double. This allows changing
    /// the value of the parameter during run-time.
    ///
    /// The input should be a scalar double between 0.0 and 1.0. Setting it to 1.0
    /// means there will be no suppression based on IOU.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string IouThresholdInputFeatureName {
      get { return iouThresholdInputFeatureName_; }
      set {
        iouThresholdInputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "confidenceThresholdInputFeatureName" field.</summary>
    public const int ConfidenceThresholdInputFeatureNameFieldNumber = 203;
    private string confidenceThresholdInputFeatureName_ = "";
    /// <summary>
    ///
    /// The confidenceThreshold can be optionally overridden by specifying this
    /// string and providing a corresponding input. This allows changing the
    /// value of the parameter during run-time, which can aid setting it just
    /// right for a particular use case.
    ///
    /// The input should be a scalar double with nonnegative value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ConfidenceThresholdInputFeatureName {
      get { return confidenceThresholdInputFeatureName_; }
      set {
        confidenceThresholdInputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "confidenceOutputFeatureName" field.</summary>
    public const int ConfidenceOutputFeatureNameFieldNumber = 210;
    private string confidenceOutputFeatureName_ = "";
    /// <summary>
    ///
    /// Set the name of the confidence output. The output will be the same type
    /// and shape as the corresponding input. The only difference is that the
    /// number of rows may have been reduced.
    ///
    /// Specifying shape is optional. One reason to specify shape is to limit
    /// the number of output boxes. This can be done is several ways:
    ///
    /// Fixed shape:
    /// The output can be pinned to a fixed set of boxes. If this number is larger
    /// than the number of boxes that would have been returned, the output is padded
    /// with zeros for both confidence and coordinates. Specifying a fixed shape
    /// can be done by setting either shape (deprecated) or allowedShapes set to
    /// fixedsize.
    ///
    /// Min/max:
    /// It is also possible to set both a minimum and a maximum. The same zero-padding
    /// as for fixed shape is applied when necessary. Setting min/max is done by defining
    /// two allowedShapes, where the first dimension uses a rangeofsizes defining lowerbound
    /// and upperbound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ConfidenceOutputFeatureName {
      get { return confidenceOutputFeatureName_; }
      set {
        confidenceOutputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "coordinatesOutputFeatureName" field.</summary>
    public const int CoordinatesOutputFeatureNameFieldNumber = 211;
    private string coordinatesOutputFeatureName_ = "";
    /// <summary>
    ///
    /// Set the name of the coordinates output. The output will be the same type
    /// and shape as the corresponding input. The only difference is that the
    /// number of rows may have been reduced.
    ///
    /// Specifying shape is optional. See confidence output for a more detailed
    /// description. Note that to achieve either fixed shape output or a
    /// constraint range of boxes, only one of confidence or coordinates need to
    /// set a shape. Both shapes are allowed to be defined, but in such case they
    /// have to be consistent along dimension 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CoordinatesOutputFeatureName {
      get { return coordinatesOutputFeatureName_; }
      set {
        coordinatesOutputFeatureName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object suppressionMethod_;
    /// <summary>Enum of possible cases for the "SuppressionMethod" oneof.</summary>
    public enum SuppressionMethodOneofCase {
      None = 0,
      PickTop = 1,
    }
    private SuppressionMethodOneofCase suppressionMethodCase_ = SuppressionMethodOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SuppressionMethodOneofCase SuppressionMethodCase {
      get { return suppressionMethodCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSuppressionMethod() {
      suppressionMethodCase_ = SuppressionMethodOneofCase.None;
      suppressionMethod_ = null;
    }

    private object classLabels_;
    /// <summary>Enum of possible cases for the "ClassLabels" oneof.</summary>
    public enum ClassLabelsOneofCase {
      None = 0,
      StringClassLabels = 100,
      Int64ClassLabels = 101,
    }
    private ClassLabelsOneofCase classLabelsCase_ = ClassLabelsOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClassLabelsOneofCase ClassLabelsCase {
      get { return classLabelsCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClassLabels() {
      classLabelsCase_ = ClassLabelsOneofCase.None;
      classLabels_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NonMaximumSuppression);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NonMaximumSuppression other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PickTop, other.PickTop)) return false;
      if (!object.Equals(StringClassLabels, other.StringClassLabels)) return false;
      if (!object.Equals(Int64ClassLabels, other.Int64ClassLabels)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(IouThreshold, other.IouThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ConfidenceThreshold, other.ConfidenceThreshold)) return false;
      if (ConfidenceInputFeatureName != other.ConfidenceInputFeatureName) return false;
      if (CoordinatesInputFeatureName != other.CoordinatesInputFeatureName) return false;
      if (IouThresholdInputFeatureName != other.IouThresholdInputFeatureName) return false;
      if (ConfidenceThresholdInputFeatureName != other.ConfidenceThresholdInputFeatureName) return false;
      if (ConfidenceOutputFeatureName != other.ConfidenceOutputFeatureName) return false;
      if (CoordinatesOutputFeatureName != other.CoordinatesOutputFeatureName) return false;
      if (SuppressionMethodCase != other.SuppressionMethodCase) return false;
      if (ClassLabelsCase != other.ClassLabelsCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (suppressionMethodCase_ == SuppressionMethodOneofCase.PickTop) hash ^= PickTop.GetHashCode();
      if (classLabelsCase_ == ClassLabelsOneofCase.StringClassLabels) hash ^= StringClassLabels.GetHashCode();
      if (classLabelsCase_ == ClassLabelsOneofCase.Int64ClassLabels) hash ^= Int64ClassLabels.GetHashCode();
      if (IouThreshold != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(IouThreshold);
      if (ConfidenceThreshold != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ConfidenceThreshold);
      if (ConfidenceInputFeatureName.Length != 0) hash ^= ConfidenceInputFeatureName.GetHashCode();
      if (CoordinatesInputFeatureName.Length != 0) hash ^= CoordinatesInputFeatureName.GetHashCode();
      if (IouThresholdInputFeatureName.Length != 0) hash ^= IouThresholdInputFeatureName.GetHashCode();
      if (ConfidenceThresholdInputFeatureName.Length != 0) hash ^= ConfidenceThresholdInputFeatureName.GetHashCode();
      if (ConfidenceOutputFeatureName.Length != 0) hash ^= ConfidenceOutputFeatureName.GetHashCode();
      if (CoordinatesOutputFeatureName.Length != 0) hash ^= CoordinatesOutputFeatureName.GetHashCode();
      hash ^= (int) suppressionMethodCase_;
      hash ^= (int) classLabelsCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (suppressionMethodCase_ == SuppressionMethodOneofCase.PickTop) {
        output.WriteRawTag(10);
        output.WriteMessage(PickTop);
      }
      if (classLabelsCase_ == ClassLabelsOneofCase.StringClassLabels) {
        output.WriteRawTag(162, 6);
        output.WriteMessage(StringClassLabels);
      }
      if (classLabelsCase_ == ClassLabelsOneofCase.Int64ClassLabels) {
        output.WriteRawTag(170, 6);
        output.WriteMessage(Int64ClassLabels);
      }
      if (IouThreshold != 0D) {
        output.WriteRawTag(241, 6);
        output.WriteDouble(IouThreshold);
      }
      if (ConfidenceThreshold != 0D) {
        output.WriteRawTag(249, 6);
        output.WriteDouble(ConfidenceThreshold);
      }
      if (ConfidenceInputFeatureName.Length != 0) {
        output.WriteRawTag(194, 12);
        output.WriteString(ConfidenceInputFeatureName);
      }
      if (CoordinatesInputFeatureName.Length != 0) {
        output.WriteRawTag(202, 12);
        output.WriteString(CoordinatesInputFeatureName);
      }
      if (IouThresholdInputFeatureName.Length != 0) {
        output.WriteRawTag(210, 12);
        output.WriteString(IouThresholdInputFeatureName);
      }
      if (ConfidenceThresholdInputFeatureName.Length != 0) {
        output.WriteRawTag(218, 12);
        output.WriteString(ConfidenceThresholdInputFeatureName);
      }
      if (ConfidenceOutputFeatureName.Length != 0) {
        output.WriteRawTag(146, 13);
        output.WriteString(ConfidenceOutputFeatureName);
      }
      if (CoordinatesOutputFeatureName.Length != 0) {
        output.WriteRawTag(154, 13);
        output.WriteString(CoordinatesOutputFeatureName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (suppressionMethodCase_ == SuppressionMethodOneofCase.PickTop) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PickTop);
      }
      if (classLabelsCase_ == ClassLabelsOneofCase.StringClassLabels) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StringClassLabels);
      }
      if (classLabelsCase_ == ClassLabelsOneofCase.Int64ClassLabels) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Int64ClassLabels);
      }
      if (IouThreshold != 0D) {
        size += 2 + 8;
      }
      if (ConfidenceThreshold != 0D) {
        size += 2 + 8;
      }
      if (ConfidenceInputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ConfidenceInputFeatureName);
      }
      if (CoordinatesInputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CoordinatesInputFeatureName);
      }
      if (IouThresholdInputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(IouThresholdInputFeatureName);
      }
      if (ConfidenceThresholdInputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ConfidenceThresholdInputFeatureName);
      }
      if (ConfidenceOutputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ConfidenceOutputFeatureName);
      }
      if (CoordinatesOutputFeatureName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(CoordinatesOutputFeatureName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NonMaximumSuppression other) {
      if (other == null) {
        return;
      }
      if (other.IouThreshold != 0D) {
        IouThreshold = other.IouThreshold;
      }
      if (other.ConfidenceThreshold != 0D) {
        ConfidenceThreshold = other.ConfidenceThreshold;
      }
      if (other.ConfidenceInputFeatureName.Length != 0) {
        ConfidenceInputFeatureName = other.ConfidenceInputFeatureName;
      }
      if (other.CoordinatesInputFeatureName.Length != 0) {
        CoordinatesInputFeatureName = other.CoordinatesInputFeatureName;
      }
      if (other.IouThresholdInputFeatureName.Length != 0) {
        IouThresholdInputFeatureName = other.IouThresholdInputFeatureName;
      }
      if (other.ConfidenceThresholdInputFeatureName.Length != 0) {
        ConfidenceThresholdInputFeatureName = other.ConfidenceThresholdInputFeatureName;
      }
      if (other.ConfidenceOutputFeatureName.Length != 0) {
        ConfidenceOutputFeatureName = other.ConfidenceOutputFeatureName;
      }
      if (other.CoordinatesOutputFeatureName.Length != 0) {
        CoordinatesOutputFeatureName = other.CoordinatesOutputFeatureName;
      }
      switch (other.SuppressionMethodCase) {
        case SuppressionMethodOneofCase.PickTop:
          if (PickTop == null) {
            PickTop = new global::CoreML.Specification.NonMaximumSuppression.Types.PickTop();
          }
          PickTop.MergeFrom(other.PickTop);
          break;
      }

      switch (other.ClassLabelsCase) {
        case ClassLabelsOneofCase.StringClassLabels:
          if (StringClassLabels == null) {
            StringClassLabels = new global::CoreML.Specification.StringVector();
          }
          StringClassLabels.MergeFrom(other.StringClassLabels);
          break;
        case ClassLabelsOneofCase.Int64ClassLabels:
          if (Int64ClassLabels == null) {
            Int64ClassLabels = new global::CoreML.Specification.Int64Vector();
          }
          Int64ClassLabels.MergeFrom(other.Int64ClassLabels);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::CoreML.Specification.NonMaximumSuppression.Types.PickTop subBuilder = new global::CoreML.Specification.NonMaximumSuppression.Types.PickTop();
            if (suppressionMethodCase_ == SuppressionMethodOneofCase.PickTop) {
              subBuilder.MergeFrom(PickTop);
            }
            input.ReadMessage(subBuilder);
            PickTop = subBuilder;
            break;
          }
          case 802: {
            global::CoreML.Specification.StringVector subBuilder = new global::CoreML.Specification.StringVector();
            if (classLabelsCase_ == ClassLabelsOneofCase.StringClassLabels) {
              subBuilder.MergeFrom(StringClassLabels);
            }
            input.ReadMessage(subBuilder);
            StringClassLabels = subBuilder;
            break;
          }
          case 810: {
            global::CoreML.Specification.Int64Vector subBuilder = new global::CoreML.Specification.Int64Vector();
            if (classLabelsCase_ == ClassLabelsOneofCase.Int64ClassLabels) {
              subBuilder.MergeFrom(Int64ClassLabels);
            }
            input.ReadMessage(subBuilder);
            Int64ClassLabels = subBuilder;
            break;
          }
          case 881: {
            IouThreshold = input.ReadDouble();
            break;
          }
          case 889: {
            ConfidenceThreshold = input.ReadDouble();
            break;
          }
          case 1602: {
            ConfidenceInputFeatureName = input.ReadString();
            break;
          }
          case 1610: {
            CoordinatesInputFeatureName = input.ReadString();
            break;
          }
          case 1618: {
            IouThresholdInputFeatureName = input.ReadString();
            break;
          }
          case 1626: {
            ConfidenceThresholdInputFeatureName = input.ReadString();
            break;
          }
          case 1682: {
            ConfidenceOutputFeatureName = input.ReadString();
            break;
          }
          case 1690: {
            CoordinatesOutputFeatureName = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the NonMaximumSuppression message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      ///
      /// Pick the bounding box of the top confidence, suppress all within a radius.
      /// </summary>
      public sealed partial class PickTop : pb::IMessage<PickTop> {
        private static readonly pb::MessageParser<PickTop> _parser = new pb::MessageParser<PickTop>(() => new PickTop());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PickTop> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::CoreML.Specification.NonMaximumSuppression.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PickTop() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PickTop(PickTop other) : this() {
          perClass_ = other.perClass_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PickTop Clone() {
          return new PickTop(this);
        }

        /// <summary>Field number for the "perClass" field.</summary>
        public const int PerClassFieldNumber = 1;
        private bool perClass_;
        /// <summary>
        ///
        /// Suppression is only done among predictions with the same label
        /// (argmax of the confidence).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool PerClass {
          get { return perClass_; }
          set {
            perClass_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PickTop);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PickTop other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (PerClass != other.PerClass) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (PerClass != false) hash ^= PerClass.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (PerClass != false) {
            output.WriteRawTag(8);
            output.WriteBool(PerClass);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (PerClass != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PickTop other) {
          if (other == null) {
            return;
          }
          if (other.PerClass != false) {
            PerClass = other.PerClass;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                PerClass = input.ReadBool();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
